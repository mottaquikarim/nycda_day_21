{"home":{"content":"# NodeJS\n\n\nWelcome to **Lecture 21**! Here is a brief class breakdown.\n\n## Learning Objectives\n---\n1. What is NodeJS and why should we learn in\n2. How do we use NodeJS to write non-client side javascript?\n\n## To Do Today\n---\n\n* ### [Warmup](#warmup)\n* ### [What is Node](#what-is-node)\n* ### [Getting Started with Node](#getting-started-with-node)\n* ### [Intro to CommonJS](#intro-to-commonjs)\n* ### [Intro to NPM](#intro-to-npm)\n* ### [Command Line Scripts](#command-line-scripts)\n\n","idx":0},"title":{"content":"NodeJS","idx":1},"desc":{"content":"An introduction to the server side JavaScript runtime.","idx":2},"warmup":{"content":"# Warmup\n\nLet's begin with a quick warmup.\n\n## Exercise 1\n\nWrite a function that takes in **one** argument, a **number** N.\n\nYour program should count down from **N to 1** and at every second, it should print out asterisks (*****) for the current count.\n\nBasically, this for **N = 5**:\n\n```bash\n* * * * *\n* * * *\n* * *\n* *\n*\n```\n\n**Remember** the hard part here is that **each** line must be printed after **one** second.\n\nHere is a gif of this in action:\n\n![example](https://raw.githubusercontent.com/mottaquikarim/nycda_day_21/master/descending-string-exercise.gif)\n\n### [Fork in Samantha](http://samantha.fewd.us/#fork/mottaquikarim/NYCDA_practice_2017_02_21)\n\n## Stretch Goals\n\nCan you implement the function above using **Promises**? How about with **async/await**?\n","idx":3},"what-is-node":{"content":"# What is Node\n\nNodeJS is a JavaScript **runtime** built on Google Chrome's **V8 JavaScript Engine**.\n\n## JavaScript Engines\n\nJS engines are essentially javascript **compilers**. They take javascript code and convert it into machine code for the CPU to execute. Most companies that build web browsers have some form of their own javascript engines:\n\n* **Google**: V8\n* **Mozilla**: SpiderMonkey\n* **Apple**: JavaScriptCore\n* **Microsoft**: Chakra\n\nGoogle's **V8** engine was first developed to be wicked fast. It uses various code compilation tricks to aggressively optimize your javascript code so that it runs as fast as possible. Incidentally, this why why Google Chrome became so popular - when folks say that Chrome is a **fast browser**, they are usually referring to the speed of the **V8** engine.\n\n**NodeJS**, like Chrome, **also** runs on the **V8** engine. \n\n## JavaScript Runtime\n\nA library used by the JavaScript Engine to implement functions during runtime aka execution of a program.\nThese libraries often include functions for input/output and memory management.\n\nSome examples of JavaScript runtimes:\n\n* **NodeJS**\n* **Your web browser**\n\nYour web browser is referrred to as a **client side** runtime. NodeJS, in contrast, is a **server side runtime**.\n\n## Client-side VS Server-side\n\n### Client-Side\nA client side runtime - the browser - will perform tasks like:\n\n* Giving the developer access to the **window** object, containing functions like **document.querySelector**, etc\n* Managing network requests, which allows the developer to do stuff like **make XMLHttpRequests**\n* Creating a **clear** separation between where your javascript code gets executed and the rest of your computer's internals. Have you noticed how you can't use javascript for much else but move around DOM items in the browser? This is intentional and was designed this way for security purposes.\n\n### Server-Side\n\nA server-side runtime - NodeJS - will perform tasks like:\n\n* Give the developer programmatic access to the computer's **file system**. This allows you to create new files, read existing files, store stuff into databases, etc\n* Create, maintain, and close servers - the things that solicit requests from browsers and respond with **html** code, **images/assets**, or **JSON** strings\n\n## Event-Driven and Non-Blocking\n\nNodeJS is **event-driven** and **non-blocking**. \n\n### Event-Driven\n\nWe are already familiar with the event-driven programming paradigm. We used it extensively while writing **client-side** UI programs.\n\nThink about the **click** event in the browser. **Click** is an event that is **emitted** when the user performs a specific action. We **react** to this event by specifying a **callback** which **handles the event**.\n\nIn Node, this idea is extended to things like **opening** a file, **connecting ** to a database, **closing** a socket, etc. Effectively, each of these actions are paired with an **event** that we can add a callback to for handling.\n\nAdditionally, we can write our **own custom** events as needed for the Node programs that we write.\n\n### Non-Blocking\n\nNon blocking code refers to the **asynchronous** nature of javascript code. Again, we are very familiar with this concept thanks to our adventures in UI programming. \n\nIn fact, **event-driven** programming is an example of the **non-blocking** concept since we are effectively saying: **when** an event triggers, run a **callback**. Meanwhile, keep parsing the rest of this code.\n\n#### Example: blocking\n\n```js\nconst pause = (ms) => {\n    const d = new Date().getTime();\n    while ((new Date().getTime()) - d <= ms) {\n        /* do nothing */\n    }\n}\n\nconsole.log('This will run');\n\npause(1000); // this is a blocking call\n\nconsole.log('This will show up 1000 ms later');\n```\n\n#### Example: Non-blocking\n\n```js\nconst pause = (ms, cb) => {\n    setTimeout(() => {\n        if (cb && typeof cb === 'function') {\n            cb();\n        }\n    }, ms);\n}\nconsole.log('Run first');\n\npause(1000, () => console.log('Run 1000ms later')); // this is a NON-blocking call\n\nconsole.log('Run second');\n```\n\n\n","idx":4},"getting-started-with-node":{"content":"# Getting Started with Node\n\nLet's write our first NodeJS program.\n\n## Exercise\nHere are some relevant exercises\n\n### Problem 1\nCreate a file that consoles out 'Hello, Wrold from Node!'. Run it from your terminal.\n\n### Problem 2\nRemember the asterisk problem from the **[warmup](#warmup)**? Transfer if over to a NodeJS script and run it in your terminal.\n\n## Steps to Node\n\n1. Open **Terminal**\n2. Type in `node` - you are in node's **console**\n3. Most of the JavaScript you are used to running in Chrome is fair game (remember, Node is a runtime built on the V8 engine)\n4. Play around and explore for a bit. When you are done, press `Ctrl + D` to exit\n\n## Creating a NodeJS program\n\n1. Create a folder.\n2. Inside the folder, create a file - call it `app.js`\n3. Write any valid JavaScript you'd like. To run, open **Terminal**, navigate to your folder and run `node app.js`\n\n## The `--harmony` flag\n\nExperimental features of NodeJS are hidden under the `--harmony` flag.\n\nFor example, if you want to use `async/await`, you'll need to do the following:\n\n```bash\n> node --harmony-async-await [name_of_script].js\n```\n\n\n\n","idx":5},"intro-to-commonjs":{"content":"# Intro to CommonJS\n\nHere's a question: how do we run multiple scripts in NodeJS?\n\n## Exercises\n\nHere are some relevant exercises to work on.\n\n### Problem 1\n\nWrite a script that exports a function called **copyFile**. \n\nTakes one arg, **string** fileName.\n\nUsing the `fs` built in module, implement a simple file copy script.\n\n\n### Problem 2\n\nWrite a script that exports a function called **moveFile**. \n\nTakes two args, **string** srcFileName and **string** destFileName.\n\nUsing the `fs` built in module, implement a simple move file script.\n\n### Problem 3\n\nWrite a script that exports a function called **concatFiles**.\n\nTakes two args, **array** of **string** fileNames and **string** concatenatedFileName.\n\nUsing the fs built in module, implement a script that opens up every file in `fileNames` list and continually adds it to the `concatenatedFileName` file.\n\n**If** a fileName in the `fileNames` list does not exist, ignore.\n**If** `concatenatedFileName` file already exists, throw an error.\n\n## CommonJS Basics\n\nCommonJS allows us to load scripts that we need from **within** a javascript file.\n\nHere is how it works:\n\n### Step 1: the `require` function\n\nIn the `app.js` file, we would include something like this:\n```javascript\nconst SpotifyAPI = require('./SpotifyAPI');\n```\n\n### Step 2: the `SpotifyAPI.js` file:\n\n**Scroll down** to the bottom of this code snippet for the real important line\n```javascript\n/*******************\n    DATA TASKS\n********************/\n\n// @param urlBase {string}\nconst urlBase = 'https://api.spotify.com';\n// @param version {number}\nconst version = 1;\n\n// ^^^ these variables are now private\n// to this file. Can only be accessed\n// by calling our SpotifyAPI functions\n\nconst SpotifyAPI = {};\n\n/*\n    @func urlBuilder\n    @returns {string}\n*/\n\nSpotifyAPI.getUrlBase = () => {...};\n// getUrlBase\n\n/*\n    @func getUrlString\n    @returns {string}\n*/\n\nSpotifyAPI.getUrlString = (endpoint) => {...}; \n// getUrlString\n\n/*\n    @func search\n    @param {string} q\n    @param {string} type\n    @returns {Promise}\n    @desc - takes a searchQuery and optional\n    type arg, returns promise that makes\n    call to Spotify API\n*/\nSpotifyAPI.search = (q = reqParam(), type = 'track') => {...}; \n// SpotifyAPI.search\n\n// THIS IS THE IMPORTANT LINE\nmodule.exports = SpotifyAPI;\n```\n\n### Step 3: Profit\n\nSo what's happening here? The `module.exports` line is something like a **return** statement here. Except, instead of returning out of a function, we are exposting the **entire** SpotifyAPI object to any file that chooses to **require('./SpotifyAPI')**.\n\nThe best part of all this: **scope is protected for you!** Essentially, no variables you declare in **SpotifyAPI** that you have **not** passed to **module.exports** will be available in **app.js**.\n\nThis pattern effectively auto encloses all our code in an **IIFE** so that we don't have to.","idx":6},"intro-to-npm":{"content":"# Intro to NPM\n\nNPM is the **package manager** of NodeJS.\n\nIt is a repository of javascript libraries written by others that can be easily installed and used on any NodeJS script.\n\nWe use the `npm` command to handle node package management tasks. This comes built in with NodeJS.\n\n## Exercises\n\n### Watching JavaScript Files\nRemember how annoying it was to break out javascript files on the front-end?\n\nThis is partially because we are not able to use the **require** technique in the browser runtime...yet.\n\nBut! Let's hack around that. We will build a rudimentary version of a javascript \"build tool\". Soon enough, we will talk more in depth about some of these tools, but for now, let's make one ourselves.\n\nUsing the **[hound](https://www.npmjs.com/package/hound)** NPM module, write a file watcher that will watch a folder for any change to a **.js** file.\n\nWhen it detects such a change, it will read a **config.json** file in that directory, which will contain the following:\n\n```javascript\n{\n    \"files\": [\n        \"SpotifyAPI.js\",\n        \"PlaylistManager.js\",\n        \"app.js\"\n    ]\n}\n```\n\nYour program will read those files in order and using the **concatFile** script from earlier, generate a **bundle.js** that contains all of your code in one file.\n\nThen, as a front-end developer, you can just link your **script** tag to the **bundle.js** and not have to worry about 15123423 script tags in your HTML code.\n\n#### Stretch Goals\n\n1. Write something similar for your **css** files.\n2. Extend your **config.js** to include keys for both your **js** files list and **css** files list. Include optional keys that allow the developer to choose **where** to save the bundle.js and bundle.css and what to call it (ie: perhaps developer wants to call it **dist.js** instead of **bundle.js**, etc).\n\n## Properly setting up your project\n\nJust like there is a specific set of things we must do to **correctly** set up a HTML webpage, there are a specific set of steps needed to correctly set up a NodeJS project.\n\n1. **Create** directory to hold all the scripts needed for your NodeJS program / project\n2. `cd` into your directory\n3. Run `npm init`. Hit the **enter** key to set default values to the prompts on your terminal screen.\n\nYou will see that **NPM** has set up a file called **package.json**.\n\n**package.json** is your friend. It will store a list of all the **dependencies** your project has (for context, if your **website** uses **jquery**, then **jquery** is a dependency of your project).\n\nAs you install additional dependencies, **npm** will automatically update your **package.json**. Additionally, if you wanted to run your code in a different machine, all you need to do is pull in your **package.json** and script files that **you** wrote and run `npm install`. This will go through your package.json and download + install all the dependencies of your project for you.\n\n**package.json** has other great benefits that we can discuss when relevant. Just bear in mind that this is an excellent resource and worth creating on any new Node project via `npm init`.\n\n## Installing a Node Package\n\n1. First, find it on **[the NPM registry](https://www.npmjs.com/)**.\n2. Then, in Terminal, navigate to your NodeJS project directory root.\n3. Run `npm install --save [name_of_module]`\n\nThis will download your module, install it, and **update** your package.json with an entry pointing to the module.","idx":7},"command-line-scripts":{"content":"# Command Line Scripts\n\nComing soon :)\n\n## Ideas\n\n* Enhancing the javascript build watcher with command line tooling\n\n* Building a Simple Static Site Generator\n\n","idx":8},"__list__":["home","title","desc","warmup","what-is-node","getting-started-with-node","intro-to-commonjs","intro-to-npm","command-line-scripts"]}