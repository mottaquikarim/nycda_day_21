{"home":{"content":"# NodeJS\n\n\nWelcome to **Lecture 21**! Here is a brief class breakdown.\n\n## Learning Objectives\n---\n1. What is NodeJS and why should we learn in\n2. How do we use NodeJS to write non-client side javascript?\n\n## To Do Today\n---\n\n* ### [Warmup](#warmup)\n* ### [What is Node](#what-is-node)\n* ### [Getting Started with Node](#getting-started-with-node)\n* ### [Intro to CommonJS](#intro-to-commonjs)\n* ### [Intro to NPM](#intro-to-npm)\n* ### [Command Line Scripts](#command-line-scripts)\n\n","idx":0},"title":{"content":"NodeJS","idx":1},"desc":{"content":"An introduction to the server side JavaScript runtime.","idx":2},"warmup":{"content":"# Warmup\n\nLet's begin with a quick warmup.\n\n## Exercise 1\n\nWrite a function that takes in **one** argument, a **number** N.\n\nYour program should count down from **N to 1** and at every second, it should print out asterisks (*****) for the current count.\n\nBasically, this for **N = 5**:\n\n```bash\n* * * * *\n* * * *\n* * *\n* *\n*\n```\n\n**Remember** the hard part here is that **each** line must be printed after **one** second.\n\nHere is a gif of this in action:\n\n![example](https://raw.githubusercontent.com/mottaquikarim/nycda_day_21/master/descending-string-exercise.gif)\n\n### [Fork in Samantha](http://samantha.fewd.us/#fork/mottaquikarim/NYCDA_practice_2017_02_21)\n\n## Stretch Goals\n\nCan you implement the function above using **Promises**? How about with **async/await**?\n","idx":3},"what-is-node":{"content":"# What is Node\n\nNodeJS is a JavaScript **runtime** built on Google Chrome's **V8 JavaScript Engine**.\n\n## JavaScript Engines\n\nJS engines are essentially javascript **compilers**. They take javascript code and convert it into machine code for the CPU to execute. Most companies that build web browsers have some form of their own javascript engines:\n\n* **Google**: V8\n* **Mozilla**: SpiderMonkey\n* **Apple**: JavaScriptCore\n* **Microsoft**: Chakra\n\nGoogle's **V8** engine was first developed to be wicked fast. It uses various code compilation tricks to aggressively optimize your javascript code so that it runs as fast as possible. Incidentally, this why why Google Chrome became so popular - when folks say that Chrome is a **fast browser**, they are usually referring to the speed of the **V8** engine.\n\n**NodeJS**, like Chrome, **also** runs on the **V8** engine. \n\n## JavaScript Runtime\n\nA library used by the JavaScript Engine to implement functions during runtime aka execution of a program.\nThese libraries often include functions for input/output and memory management.\n\nSome examples of JavaScript runtimes:\n\n* **NodeJS**\n* **Your web browser**\n\nYour web browser is referrred to as a **client side** runtime. NodeJS, in contrast, is a **server side runtime**.\n\n## Client-side VS Server-side\n\n### Client-Side\nA client side runtime - the browser - will perform tasks like:\n\n* Giving the developer access to the **window** object, containing functions like **document.querySelector**, etc\n* Managing network requests, which allows the developer to do stuff like **make XMLHttpRequests**\n* Creating a **clear** separation between where your javascript code gets executed and the rest of your computer's internals. Have you noticed how you can't use javascript for much else but move around DOM items in the browser? This is intentional and was designed this way for security purposes.\n\n### Server-Side\n\nA server-side runtime - NodeJS - will perform tasks like:\n\n* Give the developer programmatic access to the computer's **file system**. This allows you to create new files, read existing files, store stuff into databases, etc\n* Create, maintain, and close servers - the things that solicit requests from browsers and respond with **html** code, **images/assets**, or **JSON** strings\n\n## Event-Driven and Non-Blocking\n\nNodeJS is **event-driven** and **non-blocking**. \n\n### Event-Driven\n\nWe are already familiar with the event-driven programming paradigm. We used it extensively while writing **client-side** UI programs.\n\nThink about the **click** event in the browser. **Click** is an event that is **emitted** when the user performs a specific action. We **react** to this event by specifying a **callback** which **handles the event**.\n\nIn Node, this idea is extended to things like **opening** a file, **connecting ** to a database, **closing** a socket, etc. Effectively, each of these actions are paired with an **event** that we can add a callback to for handling.\n\nAdditionally, we can write our **own custom** events as needed for the Node programs that we write.\n\n### Non-Blocking\n\nNon blocking code refers to the **asynchronous** nature of javascript code. Again, we are very familiar with this concept thanks to our adventures in UI programming. \n\nIn fact, **event-driven** programming is an example of the **non-blocking** concept since we are effectively saying: **when** an event triggers, run a **callback**. Meanwhile, keep parsing the rest of this code.\n\n#### Example: blocking\n\n```js\nconst pause = (ms) => {\n    const d = new Date().getTime();\n    while ((new Date().getTime()) - d <= ms) {\n        /* do nothing */\n    }\n}\n\nconsole.log('This will run');\n\npause(1000); // this is a blocking call\n\nconsole.log('This will show up 1000 ms later');\n```\n\n#### Example: Non-blocking\n\n```js\nconst pause = (ms, cb) => {\n    setTimeout(() => {\n        if (cb && typeof cb === 'function') {\n            cb();\n        }\n    }, ms);\n}\nconsole.log('Run first');\n\npause(1000, () => console.log('Run 1000ms later')); // this is a NON-blocking call\n\nconsole.log('Run second');\n```\n\n\n","idx":4},"getting-started-with-node":{"content":"# Getting Started with Node\n","idx":5},"intro-to-commonjs":{"content":"# Intro to CommonJS\n","idx":6},"intro-to-npm":{"content":"# Intro to NPM","idx":7},"command-line-scripts":{"content":"# Command Line Scripts\n","idx":8},"__list__":["home","title","desc","warmup","what-is-node","getting-started-with-node","intro-to-commonjs","intro-to-npm","command-line-scripts"]}